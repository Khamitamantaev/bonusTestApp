# Backend Test Task

Полная постановка задания находится в [TASK.md](./TASK.md).

## Быстрый старт

```bash
docker compose up --build
```

API: `http://localhost:3000`

## Полезные команды

```bash
docker compose exec api npm run migrate
docker compose exec api npm test
docker compose down -v
```

## Запуск тестов
```bash
docker compose exec api npm test
```


## Что сдавать

- ссылка на репозиторий или ветку с изменениями;
- обновленный `README.md` с разделом `Анализ и рефакторинг` (ответы на 7 вопросов из `TASK.md`);
- инструкция запуска тестов и подтверждение, что обязательные сценарии проходят.

## Анализ и рефакторинг

### 1. Какие проблемы были в исходной реализации списания?

- **Отсутствие идемпотентности** - повторные запросы создавали новые списания
- **Гонка данных** - параллельные запросы могли увести баланс в минус
- **Учет просроченных бонусов** - expired accruals участвовали в балансе
- **Отсутствие транзакций** - операции не атомарны
- **Нет валидации** - не проверялись входные данные

### 2. Какие проблемы при одновременных запросах вы устранили и как именно?

**Проблема**: при 10 параллельных запросах на списание 60 бонусов (баланс 100) - несколько запросов могли пройти проверку и увести баланс в минус.

**Решение**:
- Транзакции с уровнем изоляции `SERIALIZABLE`
- Блокировка строк пользователя
- Расчет баланса внутри той же транзакции
- Двойная проверка идемпотентности (до и внутри транзакции)

### 3. Какие обязательные правила корректности вы обеспечили на уровне БД и на уровне кода?

**Уровень БД**:
- Уникальный составной индекс `(user_id, request_id)` для списаний
- Индекс на `expires_at` для быстрого поиска просроченных
- Внешний ключ на `user_id`

**Уровень кода**:
- Валидация входных данных
- Проверка идемпотентности
- Расчет баланса только по непросроченным начислениям
- Атомарные транзакции
- Кастомные ошибки с HTTP статусами

### 4. Как реализована защита от повторного одинакового запроса (duplicate request)?

Трехуровневая защита:

1. **Middleware** - извлекает `requestId` из заголовка или тела
2. **Проверка в коде** - до транзакции (быстрый ответ) и внутри транзакции (защита от гонок)
3. **Уникальный индекс в БД** - последний рубеж

Область идемпотентности: `(user_id, requestId)`

### 5. Как обеспечено, что просроченное начисление (expired accrual) не участвует в балансе?

В `getUserBalance` используется условие:
```javascript
where: {
  [Op.or]: [
    { expires_at: null },
    { expires_at: { [Op.gt]: new Date() } }
  ]
}
```

### 6. Как реализована защита от повторного одинакового запроса (duplicate request)?

Трехуровневая защита:

1. **attempts**: 3 - три попытки выполнения
2. **backoff**: { type: 'exponential', delay: 1000 } - экспоненциальная задержка
3. **jobId**: 'expire-accruals' - уникальный ID задачи


### 7. Какие компромиссы вы приняли в рамках ограничения 4–6 часов?

1. Уровень изоляции **SERIALIZABLE** - гарантирует консистентность, но медленнее оптимистичных блокировок
2. Поштучная обработка в очереди - надежнее, но не оптимальна для тысяч записей
3. Базовая валидация requestId - только строка, без проверки UUID формата
4. Реальная БД в тестах - медленнее моков, зато проверяет реальное поведение
5. Минимум логирования - только console.log, в проде нужен структурированный логгер



